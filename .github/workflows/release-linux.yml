name: Dexter Release Linux

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      publish_release:
        description: Publicar GitHub Release
        required: false
        type: boolean
        default: true
      tag:
        description: "Tag semver para execucao manual (ex: v0.1.0 ou v0.1.1-rc.1)"
        required: false
        type: string

concurrency:
  group: dexter-release-linux-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  release-linux:
    name: Release Linux (AppImage + deb)
    runs-on: ubuntu-latest
    timeout-minutes: 35

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install Xvfb
        run: sudo apt-get update && sudo apt-get install -y xvfb xauth

      - name: Validate quality gate
        run: |
          npm run check
          npm run build
          xvfb-run --auto-servernum --server-args="-screen 0 1440x900x24" npx playwright test

      - name: Build Linux artifacts
        run: npm run dist

      - name: Resolve release metadata
        id: meta
        run: |
          semver_pattern='^v[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?(\+[0-9A-Za-z.-]+)?$'
          should_publish="false"
          tag=""
          package_version="$(node -p "require('./package.json').version")"

          if [ "${GITHUB_EVENT_NAME}" = "push" ] && [ "${GITHUB_REF_TYPE}" = "tag" ]; then
            should_publish="true"
            tag="${GITHUB_REF_NAME}"
          elif [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            should_publish="$(node -e "const fs = require('fs'); const payload = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH, 'utf8')); process.stdout.write(String(payload.inputs?.publish_release ?? 'true'));")"
            tag="$(node -e "const fs = require('fs'); const payload = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH, 'utf8')); process.stdout.write(String(payload.inputs?.tag ?? ''));")"
          fi

          if [ "${should_publish}" = "true" ] && [ -z "${tag}" ]; then
            echo "Para publicar release manual, informe uma tag (ex: v0.1.0)."
            exit 1
          fi

          if [ "${should_publish}" = "true" ] && ! [[ "${tag}" =~ ${semver_pattern} ]]; then
            echo "Tag invalida para release: '${tag}'. Use semver com prefixo v (ex: v0.1.0 ou v0.1.1-rc.1)."
            exit 1
          fi

          if [ "${should_publish}" = "true" ]; then
            tag_version="${tag#v}"
            if [ "${tag_version}" != "${package_version}" ]; then
              echo "Tag '${tag}' diferente da versao do package.json (${package_version})."
              echo "Atualize a versao do pacote ou use a tag correspondente."
              exit 1
            fi
          fi

          if [ -z "${tag}" ]; then
            tag="linux-build-${GITHUB_RUN_NUMBER}"
          fi

          is_prerelease="false"
          if [[ "${tag}" == *-* ]]; then
            is_prerelease="true"
          fi

          echo "should_publish=${should_publish}" >> "${GITHUB_OUTPUT}"
          echo "tag=${tag}" >> "${GITHUB_OUTPUT}"
          echo "name=Dexter Linux ${tag}" >> "${GITHUB_OUTPUT}"
          echo "is_prerelease=${is_prerelease}" >> "${GITHUB_OUTPUT}"

      - name: Verify artifacts and generate checksums
        run: |
          shopt -s nullglob
          appimages=(release/*.AppImage)
          debs=(release/*.deb)

          if [ "${#appimages[@]}" -eq 0 ] || [ "${#debs[@]}" -eq 0 ]; then
            echo "Artefatos esperados nao encontrados em release/."
            ls -la release || true
            exit 1
          fi

          sha256sum "${appimages[@]}" "${debs[@]}" > release/SHA256SUMS.txt
          cat release/SHA256SUMS.txt

      - name: Generate update manifest
        run: |
          shopt -s nullglob
          appimages=(release/*.AppImage)

          if [ "${#appimages[@]}" -eq 0 ]; then
            echo "AppImage nao encontrado para gerar manifesto de update."
            exit 1
          fi

          appimage_path="${appimages[0]}"
          appimage_name="$(basename "${appimage_path}")"
          checksum="$(awk -v file="release/${appimage_name}" '$2==file {print $1}' release/SHA256SUMS.txt)"

          if [ -z "${checksum}" ]; then
            echo "Checksum nao encontrado para ${appimage_name} em release/SHA256SUMS.txt"
            exit 1
          fi

          package_version="$(node -p "require('./package.json').version")"
          channel="stable"
          if [[ "${{ steps.meta.outputs.tag }}" == *-* ]]; then
            channel="rc"
          fi

          download_url="https://github.com/${GITHUB_REPOSITORY}/releases/download/${{ steps.meta.outputs.tag }}/${appimage_name}"
          published_at="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          export DEXTER_UPDATE_MANIFEST_VERSION="${package_version}"
          export DEXTER_UPDATE_MANIFEST_CHANNEL="${channel}"
          export DEXTER_UPDATE_MANIFEST_CHECKSUM="${checksum}"
          export DEXTER_UPDATE_MANIFEST_DOWNLOAD_URL="${download_url}"
          export DEXTER_UPDATE_MANIFEST_PUBLISHED_AT="${published_at}"

          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const outFile = path.join(process.cwd(), 'release', 'dexter-update-manifest.json');
          const version = process.env.DEXTER_UPDATE_MANIFEST_VERSION;
          const channel = process.env.DEXTER_UPDATE_MANIFEST_CHANNEL;
          const checksum = process.env.DEXTER_UPDATE_MANIFEST_CHECKSUM;
          const downloadUrl = process.env.DEXTER_UPDATE_MANIFEST_DOWNLOAD_URL;
          const publishedAt = process.env.DEXTER_UPDATE_MANIFEST_PUBLISHED_AT;

          const manifest = {
            version,
            channel,
            provider: 'github',
            publishedAt,
            releaseNotes: 'Consulte as notas da release no GitHub (generate_release_notes).',
            downloadUrl,
            checksumSha256: checksum,
            components: {
              appVersion: version,
              coreVersion: version,
              uiVersion: version,
              ipcContractVersion: 1,
              userDataSchemaVersion: 1
            },
            compatibility: {
              strategy: 'atomic',
              requiresRestart: true,
              ipcContractCompatible: true,
              userDataSchemaCompatible: true,
              notes: []
            }
          };

          fs.writeFileSync(outFile, JSON.stringify(manifest, null, 2));
          console.log(fs.readFileSync(outFile, 'utf8'));
          NODE

      - name: Sign update manifest
        env:
          SHOULD_PUBLISH: ${{ steps.meta.outputs.should_publish }}
          DEXTER_UPDATE_MANIFEST_PRIVATE_KEY_PEM: ${{ secrets.DEXTER_UPDATE_MANIFEST_PRIVATE_KEY_PEM }}
        run: |
          manifest_path="release/dexter-update-manifest.json"
          sig_path="${manifest_path}.sig"

          if [ ! -f "${manifest_path}" ]; then
            echo "Manifesto de update nao encontrado em ${manifest_path}"
            exit 1
          fi

          if [ -z "${DEXTER_UPDATE_MANIFEST_PRIVATE_KEY_PEM}" ]; then
            if [ "${SHOULD_PUBLISH}" = "true" ]; then
              echo "Secret DEXTER_UPDATE_MANIFEST_PRIVATE_KEY_PEM e obrigatoria para publicar release com manifesto assinado."
              exit 1
            fi

            echo "Chave privada ausente; assinatura do manifesto sera pulada (build local/artifact-only)."
            exit 0
          fi

          export DEXTER_MANIFEST_PATH="${manifest_path}"
          export DEXTER_MANIFEST_SIG_PATH="${sig_path}"
          node - <<'NODE'
          const fs = require('fs');
          const crypto = require('crypto');

          const manifestPath = process.env.DEXTER_MANIFEST_PATH;
          const sigPath = process.env.DEXTER_MANIFEST_SIG_PATH;
          const privateKeyPem = String(process.env.DEXTER_UPDATE_MANIFEST_PRIVATE_KEY_PEM || '').replace(/\\n/g, '\n');

          const bytes = fs.readFileSync(manifestPath);
          const signature = crypto.sign(null, bytes, privateKeyPem).toString('base64');
          fs.writeFileSync(sigPath, `${signature}\n`, 'utf8');
          console.log(`Manifesto assinado: ${sigPath}`);
          NODE

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dexter-linux-${{ steps.meta.outputs.tag }}
          path: |
            release/*.AppImage
            release/*.deb
            release/SHA256SUMS.txt
            release/dexter-update-manifest.json*
          if-no-files-found: error

      - name: Publish GitHub Release
        if: steps.meta.outputs.should_publish == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.name }}
          prerelease: ${{ steps.meta.outputs.is_prerelease }}
          target_commitish: ${{ github.sha }}
          generate_release_notes: true
          files: |
            release/*.AppImage
            release/*.deb
            release/SHA256SUMS.txt
            release/dexter-update-manifest.json*
          fail_on_unmatched_files: true
